#include <pch.hpp>
#include "../../include/core/timer.hpp"
#include "../../include/core/engine.hpp"
namespace hp_ip
{
	void Engine::run( const WindowConfig& windowConfig )
	{
		_pWindow = HP_NEW Window( _name, windowConfig );
		if ( _pWindow->open( ) )
		{
			_pRenderer = HP_NEW Renderer( windowConfig );
			if ( _pRenderer->init( _pWindow->handle( ) ) )
			{
				for ( auto& actor : _actors )
				{
					actor.init( _resources, _pRenderer );
				}
				Timer timer;
				while ( _pWindow->isOpen( ) )
				{
					_pWindow->processMessages( );
					double deltaMs = timer.update( );
					for ( auto& actor : _actors )
					{
						actor.update( static_cast<float>( deltaMs ), _pWindow->gameInput( ) );
					}
					_pRenderer->swapCameras( );
					_pRenderer->preRender( );
					for ( auto& actor : _actors )
					{
						actor.render( _pRenderer );
					}
					_pRenderer->present( );
				}
			}
			else
			{
				ERR( "Failed to initialize renderer." );
			}
		}
		else
		{
			ERR( "Failed to open a window." );
		}
	}
	void Engine::addActor( Actor&& actor )
	{
		_actors.push_back( std::move( actor ) );
	}
}

#include <pch.hpp>
#include "../../include/core/resources.hpp"
namespace hp_ip
{
	Resources::~Resources( )
	{
		for ( auto model : _loadedModels )
		{
			HP_DELETE( model.second );
		}
		for ( auto model : _builtInModels )
		{
			HP_DELETE( model.second );
		}
		for ( auto material : _materials )
		{
			HP_DELETE( material.second );
		}
	};
	Model* Resources::getModel( Renderer* pRenderer, const LoadedModelDef& loadedModelDef )
	{
		if ( _loadedModels.count( loadedModelDef ) == 0 )
		{
			_loadedModels.emplace( loadedModelDef,
				Model::loadModelFromFile( pRenderer, loadedModelDef ) );
		}
		return _loadedModels.at( loadedModelDef );
	}
	Model* Resources::getModel( Renderer* pRenderer, const BuiltInModelDef& builtInModelDef )
	{
		if ( _builtInModels.count( builtInModelDef ) == 0 )
		{
			switch ( std::get<0>( builtInModelDef ) )
			{
			case BuiltInModelType::Box:
			{
				_builtInModels.emplace( builtInModelDef,
					Model::cubeMesh( pRenderer, std::get<1>( builtInModelDef ) ) );
			}
			break;
			default:
				WAR( "Missing built-In model for type " +
					std::to_string( static_cast<UInt8>( std::get<0>( builtInModelDef ) ) ) + "." );
			}
		}
		return _builtInModels.at( builtInModelDef );
	}
	Material* Resources::getMaterial( Renderer* pRenderer, const MaterialDef& materialDef )
	{
		if ( _materials.count( materialDef ) == 0 )
		{
			_materials.emplace( materialDef, Material::loadMaterial( pRenderer, materialDef ) );
		}
		return _materials.at( materialDef );
	}
}

#include <pch.hpp>
#include "../../include/core/timer.hpp"
namespace hp_ip
{
	// http://randomascii.wordpress.com/2012/02/13/dont-store-that-in-a-float/
	// start timer at 2^32 to gain best precision
	const double TIME_ADDITION = 4294967296;
	double Timer::update( )
	{
		double currentTimeMs = getTimeMs( );
		double deltaMs = currentTimeMs - _lastTimeMs;
		_lastTimeMs = currentTimeMs;
		_timeMs += deltaMs;
		return deltaMs;
	}
	double Timer::getTimeMs( )
	{
		// use only single thread to calculate time
		HANDLE currentThread = GetCurrentThread( );
		DWORD_PTR previousMask = SetThreadAffinityMask( currentThread, 1 );
		static LARGE_INTEGER frequency;
		LARGE_INTEGER time;
		QueryPerformanceFrequency( &frequency );
		QueryPerformanceCounter( &time );
		// use previously used thread
		SetThreadAffinityMask( currentThread, previousMask );
		return double( 1000 * time.QuadPart / frequency.QuadPart );
	}
}

#include <pch.hpp>
#include "../../../include/core/actor/actor.hpp"
#include "../../../include/math/mat4x4.hpp"
namespace hp_ip
{
	void Actor::init( Resources& resources, Renderer* pRenderer )
	{
		for ( auto* component : _components )
		{
			component->vInit( resources, pRenderer );
		}
		for ( auto& child : _children )
		{
			child.init( resources, pRenderer );
		}
	}
	void Actor::update( const float deltaMs, const GameInput& input )
	{
		_pTransformComponent->vUpdate( deltaMs, input );
		Mat4x4 transform = _pTransformComponent->transform( );
		for ( auto* component : _components )
		{
			component->vUpdate( deltaMs, input );
		}
		for ( auto& child : _children )
		{
			child.transformComponent( ).setParentTransform( transform );
			child.update( deltaMs, input );
		}
	}
	void Actor::render( Renderer* pRenderer )
	{
		for ( auto* component : _components )
		{
			component->vRender( pRenderer );
		}
		for ( auto& child : _children )
		{
			child.render( pRenderer );
		}
	}
	void Actor::addComponent( iComponent* component )
	{
		_components.push_back( component );
		component->_owner = this;
	}
	void Actor::addComponent( TransformComponent* component )
	{
		_pTransformComponent = component;
		_pTransformComponent->_owner = this;
	}
}

#include <pch.hpp>
#include "../../../../include/core/actor/component/cameraComponent.hpp"
#include "../../../../include/core/actor/actor.hpp"
#include "../../../../include/graphics/renderer.hpp"
namespace hp_ip
{
	void CameraComponent::vInit( Resources& resources, Renderer* pRenderer )
	{
		_pRenderer = pRenderer;
		_frustum = init( static_cast<float>( PI ) / 4.f,
			static_cast<float>( pRenderer->windowConfig( ).width ) /
			pRenderer->windowConfig( ).height,
			_cameraDef.nearClipDist, _cameraDef.farClipDist );
		_projection = matrixPerspectiveFovLH( _frustum.fieldOfView,
			_frustum.aspectRatio, _frustum.nearClipDist, _frustum.farClipDist );
	}
	void CameraComponent::vUpdate( const float deltaMs, const GameInput& input )
	{
		_pRenderer->setCamera( { _projection, _owner->transformComponent( ).modelTransform( ) } );
	}
}

#include <pch.hpp>
#include "../../../../include/core/actor/component/modelComponent.hpp"
#include "../../../../include/core/resources.hpp"
#include "../../../../include/core/actor/actor.hpp"
#include "../../../../include/graphics/renderer.hpp"
namespace hp_ip
{
	void ModelComponent::vInit( Resources& resources, Renderer* pRenderer )
	{
		switch ( _type )
		{
		case ModelType::Loaded:
		{
			_model = resources.getModel( pRenderer, _loadedModelDef );
		}
		break;
		case ModelType::BuiltIn:
		{
			_model = resources.getModel( pRenderer, _builtInModelDef );
		}
		break;
		default:
			WAR( "Invalid model type." );
		}
		_material = resources.getMaterial( pRenderer, _materialDef );
	}
	void ModelComponent::vRender( Renderer* pRenderer )
	{
		if ( _owner != nullptr )
		{
			const Camera& cam = pRenderer->getCamera( );
			_material->setProjection( cam.projection );
			_material->setView( inverse( cam.transform ) );
			_material->setWorld( _owner->transformComponent( ).modelTransform( ) );
			_material->setCameraPosition( pos( cam.transform ) );
			_material->setAbientLightColor( Color( 0.1f, 0.1f, 0.1f, 0.6f ) );
			_material->setDiffuseLightColor( Color( 1.0f, 0.95f, 0.4f, 0.4f ) );
			_material->setSpecularLightColor( Color( 1.0f, 1.0f, 1.0f, 0.3f ) );
			_material->setLightDirection( FVec3{ -0.5f, -1.0f, 0.1f } );
			_material->setTextures( );
			_material->setMaterials( );
			_material->bindInputLayout( pRenderer );
			for ( UInt32 i = 0; i < _material->getPassCount( ); ++i )
			{
				_material->applyPass( pRenderer, i );
				for ( UInt32 j = 0; j < _model->_meshes.size( ); ++j )
				{
					pRenderer->setBuffers( _model->_meshes[j] );
					pRenderer->drawIndexed( _model->_meshes[j].indicesSize( ), 0, 0 );
				}
			}
		}
	}
}

#include <pch.hpp>
#include "../../../../include/core/actor/component/transformComponent.hpp"
namespace hp_ip
{
	void TransformComponent::vUpdate( const float deltaMs, const GameInput& input )
	{
		_pos += _vel * deltaMs;
	}
	Mat4x4 TransformComponent::transform( ) const
	{
		return rotSclPosToMat4x4( _rot, _scl, _pos ) * _parentTransform;
	}
	Mat4x4 TransformComponent::modelTransform( ) const
	{
		return rotSclPosToMat4x4( _modelRot * _rot, _scl, _pos ) * _parentTransform;
	}
}

#include <pch.hpp>
#include "../../include/graphics/camera.hpp"
namespace hp_ip
{
	const Camera& CameraBuffer::getCamera( )
	{
		if ( _first )
		{
			return _cam[0];
		}
		else
		{
			return _cam[1];
		}
	}
	void CameraBuffer::setCamera( Camera&& camera )
	{
		if ( _first )
		{
			_cam[1] = camera;
		}
		else
		{
			_cam[0] = camera;
		}
	}
	void CameraBuffer::swap( )
	{
		_first = !_first;
	}
}

#include <pch.hpp>
#include "../../include/graphics/material.hpp"
#include "../../include/graphics/renderer.hpp"
#include "../../include/graphics/vertex.hpp"
namespace hp_ip
{
	Material* Material::loadMaterial( Renderer* pRenderer, const MaterialDef& materialDef )
	{
		Material* material = HP_NEW Material
		{
			"assets/shaders/parallax.fx", // filename
			"Render", // techniqueName
			{ 1.0f, 1.0f }, // textureRepeat
			{ 0.5f, 0.5f, 0.5f }, // ambientMaterial
			{ 0.8f, 0.8f, 0.8f }, // diffuseMaterial
			{ 1.0f, 1.0f, 1.0f }, // specularMaterial
			25.0f // specularPower
		};
		bool materialLoaded;
		if ( materialLoaded = material->init( pRenderer ) )
		{
			// TODO: fix these in /Ox
			if ( materialDef.diffuseTextureFilename != "" )
			{
				materialLoaded &= material->loadDiffuseTexture( pRenderer,
					materialDef.diffuseTextureFilename );
			}
			if ( materialDef.specularTextureFilename != "" )
			{
				materialLoaded &= material->loadSpecularTexture( pRenderer,
					materialDef.specularTextureFilename );
			}
			if ( materialDef.bumpTextureFilename != "" )
			{
				materialLoaded &= material->loadBumpTexture( pRenderer,
					materialDef.bumpTextureFilename );
			}
			if ( materialDef.parallaxTextureFilename != "" )
			{
				materialLoaded &= material->loadParallaxTexture( pRenderer,
					materialDef.parallaxTextureFilename );
			}
			if ( materialDef.textureRepeat.x != 0.0f && materialDef.textureRepeat.y != 0.0f )
			{
				material->_textureRepeat = materialDef.textureRepeat;
			}
		}
		if ( materialLoaded )
		{
			return material;
		}
		HP_DELETE( material );
		return nullptr;
	}
	Material::Material( const String& filename, const String& techniqueName,
		const FVec2& textureRepeat, const Color& ambientMaterial,
		const Color& diffuseMaterial, const Color& specularMaterial,
		const float specularPower ) : _filename( filename ), _techniqueName( techniqueName ),
		_pEffect( nullptr ), _pTechnique( nullptr ), _pPass( nullptr ), _pInputLayout( nullptr ),
		_techniqueDesc( ), _pViewMatrixVariable( nullptr ), _pProjectionMatrixVariable( nullptr ),
		_pWorldMatrixVariable( nullptr ), _pDiffuseTextureVariable( nullptr ),
		_pSpecularTextureVariable( nullptr ), _pBumpTextureVariable( nullptr ),
		_pParallaxTextureVariable( nullptr ), _pEnvMapVariable( nullptr ),
		_pDiffuseTexture( nullptr ), _pSpecularTexture( nullptr ), _pBumpTexture( nullptr ),
		_pParallaxTexture( nullptr ), _pEnvMapTexture( nullptr ), _textureRepeat( textureRepeat ),
		_pUseDiffuseTextureVariable( nullptr ), _pUseSpecularTextureVariable( nullptr ),
		_pUseBumpTextureVariable( nullptr ), _pUseParallaxTextureVariable( nullptr ),
		_pAmbientLightColourVariable( nullptr ), _pDiffuseLightColourVariable( nullptr ),
		_pSpecularLightColourVariable( nullptr ), _pLightDirectionVariable( nullptr ),
		_pAmbientMaterialVariable( nullptr ), _pDiffuseMaterialVariable( nullptr ),
		_pSpecularMaterialVariable( nullptr ), _pSpecularPowerVariable( nullptr ),
		_pTextureRepeatVariable( nullptr ), _pCameraPositionVariable( nullptr ),
		_ambientMaterial( ambientMaterial ), _diffuseMaterial( diffuseMaterial ),
		_specularMaterial( specularMaterial ), _specularPower( specularPower )
	{
		ZeroMemory( &_techniqueDesc, sizeof( D3D10_TECHNIQUE_DESC ) );
	}
	Material::~Material( )
	{
		HP_RELEASE( _pEnvMapTexture );
		HP_RELEASE( _pParallaxTexture );
		HP_RELEASE( _pBumpTexture );
		HP_RELEASE( _pSpecularTexture );
		HP_RELEASE( _pDiffuseTexture );
		HP_RELEASE( _pInputLayout );
		HP_RELEASE( _pEffect );
	}
	bool Material::init( Renderer* pRenderer )
	{
		if ( loadEffectFromFile( pRenderer ) )
		{
			_pTechnique = _pEffect->GetTechniqueByName( _techniqueName.c_str( ) );
			_pTechnique->GetDesc( &_techniqueDesc );
			if ( createVertexLayout( pRenderer ) )
			{
				// retrieve all variables using semantic
				_pWorldMatrixVariable = _pEffect->GetVariableBySemantic( "WORLD" )->AsMatrix( );
				_pViewMatrixVariable = _pEffect->GetVariableBySemantic( "VIEW" )->AsMatrix( );
				_pProjectionMatrixVariable = _pEffect->GetVariableBySemantic( "PROJECTION" )->AsMatrix( );
				_pDiffuseTextureVariable = _pEffect->GetVariableByName( "diffuseMap" )->AsShaderResource( );
				_pSpecularTextureVariable = _pEffect->GetVariableByName( "specularMap" )->AsShaderResource( );
				_pBumpTextureVariable = _pEffect->GetVariableByName( "bumpMap" )->AsShaderResource( );
				_pParallaxTextureVariable = _pEffect->GetVariableByName( "heightMap" )->AsShaderResource( );
				_pEnvMapVariable = _pEffect->GetVariableByName( "envMap" )->AsShaderResource( );
				// lights
				_pAmbientLightColourVariable = _pEffect->GetVariableByName( "ambientLightColour" )->AsVector( );
				_pDiffuseLightColourVariable = _pEffect->GetVariableByName( "diffuseLightColour" )->AsVector( );
				_pSpecularLightColourVariable = _pEffect->GetVariableByName( "specularLightColour" )->AsVector( );
				_pLightDirectionVariable = _pEffect->GetVariableByName( "lightDirection" )->AsVector( );
				// materials
				_pAmbientMaterialVariable = _pEffect->GetVariableByName( "ambientMaterialColour" )->AsVector( );
				_pDiffuseMaterialVariable = _pEffect->GetVariableByName( "diffuseMaterialColour" )->AsVector( );
				_pSpecularMaterialVariable = _pEffect->GetVariableByName( "specularMaterialColour" )->AsVector( );
				_pSpecularPowerVariable = _pEffect->GetVariableByName( "specularPower" )->AsScalar( );
				_pTextureRepeatVariable = _pEffect->GetVariableByName( "textureRepeat" )->AsVector( );
				// camera
				_pCameraPositionVariable = _pEffect->GetVariableByName( "cameraPosition" )->AsVector( );
				// booleans
				_pUseDiffuseTextureVariable = _pEffect->GetVariableByName( "useDiffuseTexture" )->AsScalar( );
				_pUseSpecularTextureVariable = _pEffect->GetVariableByName( "useSpecularTexture" )->AsScalar( );
				_pUseBumpTextureVariable = _pEffect->GetVariableByName( "useBumpTexture" )->AsScalar( );
				_pUseParallaxTextureVariable = _pEffect->GetVariableByName( "useHeightTexture" )->AsScalar( );
				return true;
			}
		}
		return false;
	}
	bool Material::createVertexLayout( Renderer* pRenderer )
	{
		UInt32 elementsCount = ARRAYSIZE( D3D11_LAYOUT );
		D3DX11_PASS_DESC passDesc;
		_pTechnique->GetPassByIndex( 0 )->GetDesc( &passDesc );
		if ( FAILED( pRenderer->device( )->CreateInputLayout( D3D11_LAYOUT, elementsCount,
			passDesc.pIAInputSignature, passDesc.IAInputSignatureSize, &_pInputLayout ) ) )
		{
			return false;
		}
		return true;
	}
	bool Material::loadDiffuseTexture( Renderer* pRenderer, const String& filename )
	{
		return loadTexture( &_pDiffuseTexture, pRenderer, filename );
	}
	bool Material::loadSpecularTexture( Renderer* pRenderer, const String& filename )
	{
		return loadTexture( &_pSpecularTexture, pRenderer, filename );
	}
	bool Material::loadBumpTexture( Renderer* pRenderer, const String& filename )
	{
		return loadTexture( &_pBumpTexture, pRenderer, filename );
	}
	bool Material::loadParallaxTexture( Renderer* pRenderer, const String& filename )
	{
		return loadTexture( &_pParallaxTexture, pRenderer, filename );
	}
	bool Material::loadEnvMapTexture( Renderer* pRenderer, const String& filename )
	{
		return loadTexture( &_pEnvMapTexture, pRenderer, filename );
	}
	void Material::bindInputLayout( Renderer* pRenderer )
	{
		pRenderer->deviceContext( )->IASetInputLayout( _pInputLayout );
	}
	void Material::applyPass( Renderer* pRenderer, UInt32 i )
	{
		_pPass = _pTechnique->GetPassByIndex( i );
		_pPass->Apply( 0, pRenderer->deviceContext( ) );
	}
	bool Material::loadEffectFromFile( Renderer* pRenderer )
	{
		ID3DBlob* pBuffer = nullptr;
		if ( !compileD3DShader( _filename, "fx_5_0", &pBuffer ) )
		{
			return false;
		}
		if ( FAILED( D3DX11CreateEffectFromMemory( pBuffer->GetBufferPointer( ),
			pBuffer->GetBufferSize( ), 0, pRenderer->device( ), &_pEffect ) ) )
		{
			HP_RELEASE( pBuffer );
			return false;
		}
		return true;
	}
	bool Material::compileD3DShader( const String& filePath, const String& shaderModel,
		ID3DBlob** ppBuffer )
	{
		std::wstring wFilePath;
		wFilePath.assign( filePath.begin( ), filePath.end( ) );
		DWORD shaderFlags = D3DCOMPILE_ENABLE_STRICTNESS;
#       ifdef HP_DEBUG
		shaderFlags |= D3DCOMPILE_DEBUG;
#       endif
		ID3DBlob* errorBuffer = 0;
		HRESULT result;
		result = D3DCompileFromFile( wFilePath.c_str( ), 0, 0, 0, shaderModel.c_str( ),
			shaderFlags, 0, ppBuffer, &errorBuffer );
		if ( FAILED( result ) )
		{
			HP_RELEASE( errorBuffer );
			ERR( "Error while compiling " + filePath + " shader." );
			return false;
		}
		HP_RELEASE( errorBuffer );
		return true;
	}
	bool Material::loadTexture( ID3D11ShaderResourceView** texture, Renderer* pRenderer,
		const String& filename )
	{
		String fileExt = filename.substr( filename.find( '.' ) + 1 );
		std::transform( fileExt.begin( ), fileExt.end( ), fileExt.begin( ), ::tolower );
		std::wstring wFilename = s2ws( filename );
		if ( fileExt.compare( "dds" ) == 0 )
		{
			if ( FAILED( DirectX::CreateDDSTextureFromFile( pRenderer->device( ),
				wFilename.c_str( ), nullptr, texture ) ) )
			{
				ERR( "Failed to load \"" + filename + "\" texture." );
				return false;
			}
		}
		else
		{
			if ( FAILED( DirectX::CreateWICTextureFromFile( pRenderer->device( ),
				wFilename.c_str( ), nullptr, texture ) ) )
			{
				ERR( "Failed to load \"" + filename + "\" texture." );
				return false;
			}
		}
		return true;
	}
}

#include <pch.hpp>
#include "../../include/graphics/model.hpp"
#include <algorithm>
#include <fbxsdk.h>
#pragma comment(lib, "libfbxsdk-md.lib")
#include "../../include/graphics/renderer.hpp"
namespace hp_ip
{
	Model::Model( )
	{

	}
	Model* Model::loadModelFromFile( Renderer* pRenderer, const LoadedModelDef& loadedModelDef )
	{
		String filename = std::get<0>( loadedModelDef );
		String fileExt{ filename.substr( filename.find( '.' ) + 1 ) };
		std::transform( fileExt.begin( ), fileExt.end( ), fileExt.begin( ), ::tolower );
		if ( fileExt.compare( "fbx" ) == 0 )
		{
			return loadModelFromFBXFile( pRenderer, filename, std::get<1>( loadedModelDef ) );
		}
		return nullptr;
	}
	Model* Model::loadModelFromFBXFile( Renderer* pRenderer, const String& filename,
		const float scale )
	{
		Model* model = HP_NEW Model( );
		FbxManager* manager = FbxManager::Create( );
		FbxIOSettings* settings = FbxIOSettings::Create( manager, IOSROOT );
		manager->SetIOSettings( settings );
		FbxImporter* importer = FbxImporter::Create( manager, "" );
		FbxGeometryConverter converter( manager );
		if ( !importer->Initialize( filename.c_str( ), -1, manager->GetIOSettings( ) ) )
		{
			HP_DELETE( model );
			return nullptr;
		}
		FbxScene* scene = FbxScene::Create( manager, "myScene" );
		FbxAxisSystem axisSystem = scene->GetGlobalSettings( ).GetAxisSystem( );
		importer->Import( scene );
		importer->Destroy( );
		FbxNode* rootNode = scene->GetRootNode( );
		FbxMesh* fbxMesh = NULL;
		if ( rootNode )
		{
			for ( Int32 i = 0; i < rootNode->GetChildCount( ); ++i )
			{
				FbxNode* childNode = rootNode->GetChild( i );
				for ( Int32 j = 0; j < childNode->GetNodeAttributeCount( ); ++j )
				{
					FbxNodeAttribute* nodeAttribute = childNode->GetNodeAttributeByIndex( j );
					converter.Triangulate( nodeAttribute, true );
					if ( nodeAttribute->GetAttributeType( ) == FbxNodeAttribute::eMesh )
					{
						fbxMesh = (FbxMesh*) ( nodeAttribute );
						if ( fbxMesh )
						{
							Mesh mesh;
							FbxVector4* fbxVertices = fbxMesh->GetControlPoints( );
							UInt32 vertexCount = fbxMesh->GetControlPointsCount( );
							UInt32 indexCount = fbxMesh->GetPolygonVertexCount( );
							Index* indices = (Index*) fbxMesh->GetPolygonVertices( );
							Vertex* vertices = new Vertex[vertexCount];
							for ( UInt32 k = 0; k < vertexCount; ++k )
							{
								vertices[k].position.x = float( fbxVertices[k][0] * scale );
								vertices[k].position.y = float( fbxVertices[k][1] * scale );
								vertices[k].position.z = float( fbxVertices[k][2] * scale );
							}

							for ( Int32 polyIndex = 0; polyIndex < fbxMesh->GetPolygonCount( ); ++polyIndex )
							{
								for ( UInt32 vertexIndex = 0; vertexIndex < 3; ++vertexIndex )
								{
									UInt32 cornerIndex = fbxMesh->GetPolygonVertex( polyIndex, vertexIndex );
									FbxVector4 fbxVertex = fbxVertices[cornerIndex];
									FbxVector4 fbxNormal;
									fbxMesh->GetPolygonVertexNormal( polyIndex, vertexIndex, fbxNormal );
									fbxNormal.Normalize( );
									vertices[cornerIndex].normal = FVec3{ float( fbxNormal[0] ),
										float( fbxNormal[1] ), float( fbxNormal[2] ) };
									FbxVector2 fbxUV = FbxVector2( 0, 0 );
									FbxLayerElementUV* fbxUVs = fbxMesh->GetLayer( 0 )->GetUVs( );
									if ( fbxUVs )
									{
										UInt32 UVIndex = 0;
										switch ( fbxUVs->GetMappingMode( ) )
										{
										case FbxLayerElement::eByControlPoint:
											UVIndex = cornerIndex;
											break;
										case FbxLayerElement::eByPolygonVertex:
											UVIndex = fbxMesh->GetTextureUVIndex( polyIndex, vertexIndex, FbxLayerElement::eTextureDiffuse );
											break;
										}
										fbxUV = fbxUVs->GetDirectArray( ).GetAt( UVIndex );
										vertices[cornerIndex].texCoord.x = float( fbxUV[0] );
										vertices[cornerIndex].texCoord.y = float( 1.0 - fbxUV[1] );
									}
								}
							}
							computeTangentsAndBinormals( vertices, vertexCount, indices, indexCount );
							for ( UInt32 k = 0; k < vertexCount; ++k )
							{
								addVertex( mesh, vertices[k] );
							}
							for ( UInt32 k = 0; k < indexCount; ++k )
							{
								addIndex( mesh, indices[k] );
							}
							HP_DELETE_ARRAY( vertices );
							model->_meshes.push_back( std::move( mesh ) );
						}
					}
				}
			}
			bool buffersCreated = true;
			for ( auto& mesh : model->_meshes )
			{
				buffersCreated &= createBuffers( pRenderer, mesh );
			}
			if ( buffersCreated )
			{
				settings->Destroy( );
				manager->Destroy( );
				return model;
			}
			else
			{
				ERR( "Failed to initalize \"" + filename + "\"'s buffers." );
			}
		}
		ERR( "Failed to load \"" + filename + "\" model." );
		settings->Destroy( );
		manager->Destroy( );
		HP_DELETE( model );
		return nullptr;
	}
	Model* Model::cubeMesh( Renderer* pRenderer, const FVec3& dimensions )
	{
		Model* model = cubeMesh( dimensions );
		bool buffersCreated = true;
		for ( auto& mesh : model->_meshes )
		{
			buffersCreated &= createBuffers( pRenderer, mesh );
		}
		if ( buffersCreated )
		{
			return model;
		}
		ERR( "Failed to initalize cube's buffers." );
		HP_DELETE( model );
		return nullptr;
	}
	void Model::computeTangentsAndBinormals( Vertex* vertices, UInt32 vertexCount,
		UInt32* indices, UInt32 indexCount )
	{
		UInt32 triCount = indexCount / 3;
		FVec3* tangents = HP_NEW FVec3[vertexCount];
		FVec3* binormals = HP_NEW FVec3[vertexCount];
		for ( UInt32 i = 0; i < triCount; i += 3 )
		{
			FVec3 v1 = vertices[indices[i]].position;
			FVec3 v2 = vertices[indices[i + 1]].position;
			FVec3 v3 = vertices[indices[i + 2]].position;
			FVec2 uv1 = vertices[indices[i]].texCoord;
			FVec2 uv2 = vertices[indices[i + 1]].texCoord;
			FVec2 uv3 = vertices[indices[i + 2]].texCoord;
			FVec3 edge1 = v2 - v1;
			FVec3 edge2 = v3 - v1;
			FVec2 edge1uv = uv2 - uv1;
			FVec2 edge2uv = uv3 - uv1;
			float cp = edge1uv.x * edge2uv.y - edge1uv.y * edge2uv.x;
			if ( cp != 0.0f )
			{
				float mul = 1.0f / cp;
				FVec3 tan = ( edge1 * edge2uv.y - edge2 * edge1uv.y ) * mul;
				FVec3 binorm = ( edge1 * edge2uv.x - edge2 * edge1uv.x ) * mul;
				tangents[indices[i]] += tan;
				binormals[indices[i]] += binorm;
				tangents[indices[i + 1]] += tan;
				binormals[indices[i + 1]] += binorm;
				tangents[indices[i + 2]] += tan;
				binormals[indices[i + 2]] += binorm;
			}
		}
		for ( UInt32 i = 0; i < vertexCount; ++i )
		{
			vertices[i].tangent = FVec3::normalize( tangents[i] );
			vertices[i].binormal = FVec3::normalize( binormals[i] );
		}
		HP_DELETE_ARRAY( tangents );
		HP_DELETE_ARRAY( binormals );
	}
	void Model::addVertex( Mesh& mesh, const Vertex vertex )
	{
		mesh._vertices.push_back( vertex );
	}
	void Model::addIndex( Mesh& mesh, const Index index )
	{
		mesh._indices.push_back( index );
	}
	bool Model::createBuffers( Renderer* pRenderer, Mesh& mesh )
	{
		if ( pRenderer->createVertexBuffer( &mesh._vertexBuffer,
			sizeof( Vertex ) * mesh._vertices.size( ), &mesh._vertices.at( 0 ) ) )
		{
			if ( pRenderer->createIndexBuffer( &mesh._indexBuffer,
				sizeof( Index ) * mesh._indices.size( ), &mesh._indices.at( 0 ) ) )
			{
				return true;
			}
		}
		return false;
	}
	Model* Model::cubeMesh( const FVec3& dimensions )
	{
		Model* model = HP_NEW Model( );
		Mesh mesh;
		float halfWidth = dimensions.x / 2.f;
		float halfHeight = dimensions.y / 2.f;
		float halfLength = dimensions.z / 2.f;
		Vertex vertices[] =
		{
			{ FVec3{ -halfWidth, halfHeight, -halfLength }, Color( ), FVec2{ 0.0f, 0.0f }, FVec3::up }, // 0 +Y (top face)
			{ FVec3{ halfWidth, halfHeight, -halfLength }, Color( ), FVec2{ 1.0f, 0.0f }, FVec3::up }, // 1
			{ FVec3{ halfWidth, halfHeight, halfLength }, Color( ), FVec2{ 1.0f, 1.0f }, FVec3::up }, // 2
			{ FVec3{ -halfWidth, halfHeight, halfLength }, Color( ), FVec2{ 0.0f, 1.0f }, FVec3::up }, // 3

			{ FVec3{ -halfWidth, -halfHeight, halfLength }, Color( ), FVec2{ 0.0f, 0.0f }, -1 * FVec3::up }, // 4 -Y (bottom face)
			{ FVec3{ halfWidth, -halfHeight, halfLength }, Color( ), FVec2{ 1.0f, 0.0f }, -1 * FVec3::up }, // 5
			{ FVec3{ halfWidth, -halfHeight, -halfLength }, Color( ), FVec2{ 1.0f, 1.0f }, -1 * FVec3::up }, // 6
			{ FVec3{ -halfWidth, -halfHeight, -halfLength }, Color( ), FVec2{ 0.0f, 1.0f }, -1 * FVec3::up }, // 7

			{ FVec3{ halfWidth, halfHeight, halfLength }, Color( ), FVec2{ 0.0f, 0.0f }, FVec3::right }, // 8 +X (right face)
			{ FVec3{ halfWidth, halfHeight, -halfLength }, Color( ), FVec2{ 1.0f, 0.0f }, FVec3::right }, // 9
			{ FVec3{ halfWidth, -halfHeight, -halfLength }, Color( ), FVec2{ 1.0f, 1.0f }, FVec3::right }, // 10
			{ FVec3{ halfWidth, -halfHeight, halfLength }, Color( ), FVec2{ 0.0f, 1.0f }, FVec3::right }, // 11

			{ FVec3{ -halfWidth, halfHeight, -halfLength }, Color( ), FVec2{ 0.0f, 0.0f }, -1 * FVec3::right }, // 12 -X (left face)
			{ FVec3{ -halfWidth, halfHeight, halfLength }, Color( ), FVec2{ 1.0f, 0.0f }, -1 * FVec3::right }, // 13
			{ FVec3{ -halfWidth, -halfHeight, halfLength }, Color( ), FVec2{ 1.0f, 1.0f }, -1 * FVec3::right }, // 14
			{ FVec3{ -halfWidth, -halfHeight, -halfLength }, Color( ), FVec2{ 0.0f, 1.0f }, -1 * FVec3::right }, // 15

			{ FVec3{ -halfWidth, halfHeight, halfLength }, Color( ), FVec2{ 0.0f, 0.0f }, FVec3::forward }, // 16 +Z (front face)
			{ FVec3{ halfWidth, halfHeight, halfLength }, Color( ), FVec2{ 1.0f, 0.0f }, FVec3::forward }, // 17
			{ FVec3{ halfWidth, -halfHeight, halfLength }, Color( ), FVec2{ 1.0f, 1.0f }, FVec3::forward }, // 18
			{ FVec3{ -halfWidth, -halfHeight, halfLength }, Color( ), FVec2{ 0.0f, 1.0f }, FVec3::forward }, // 19

			{ FVec3{ halfWidth, halfHeight, -halfLength }, Color( ), FVec2{ 0.0f, 0.0f }, -1 * FVec3::forward }, // 20 -Z (back face)
			{ FVec3{ -halfWidth, halfHeight, -halfLength }, Color( ), FVec2{ 1.0f, 0.0f }, -1 * FVec3::forward }, // 21
			{ FVec3{ -halfWidth, -halfHeight, -halfLength }, Color( ), FVec2{ 1.0f, 1.0f }, -1 * FVec3::forward }, // 22
			{ FVec3{ halfWidth, -halfHeight, -halfLength }, Color( ), FVec2{ 0.0f, 1.0f }, -1 * FVec3::forward }, // 23
		};
		Index indices[] =
		{
			1, 0, 2, 2, 0, 3, // top face
			5, 4, 6, 6, 4, 7, // bottom
			9, 8, 10, 10, 8, 11, // right
			13, 12, 14, 14, 12, 15, // left
			17, 16, 18, 18, 16, 19, // front
			21, 20, 22, 22, 20, 23 // back
		};
		computeTangentsAndBinormals( vertices, 24, indices, 36 );
		for ( UInt16 i = 0; i < 24; i++ )
		{
			addVertex( mesh, vertices[i] );
		}
		for ( UInt16 i = 0; i < 36; i++ )
		{
			addIndex( mesh, indices[i] );
		}
		model->_meshes.push_back( std::move( mesh ) );
		return model;
	}
}

#include <pch.hpp>
#include "../../include/graphics/renderer.hpp"
#include "../../include/graphics/mesh.hpp"
namespace hp_ip
{
	bool Renderer::init( WindowHandle windowHandle )
	{
		// driver types for fallback
		D3D_DRIVER_TYPE driverTypes[] = { D3D_DRIVER_TYPE_HARDWARE, D3D_DRIVER_TYPE_WARP,
			D3D_DRIVER_TYPE_SOFTWARE };
		UInt8 totalDriverTypes = ARRAYSIZE( driverTypes );
		// fallback feature levels
		D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1,
			D3D_FEATURE_LEVEL_10_0 };
		UInt8 totalFeatureLevels = ARRAYSIZE( featureLevels );
		// swap chain description
		DXGI_SWAP_CHAIN_DESC swapChainDesc;
		ZeroMemory( &swapChainDesc, sizeof( swapChainDesc ) );
		swapChainDesc.BufferCount = _windowConfig.windowStyle == WindowStyle::Fullscreen ? 2 : 1;
		swapChainDesc.BufferDesc.Width = _windowConfig.width;
		swapChainDesc.BufferDesc.Height = _windowConfig.height;
		swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		swapChainDesc.BufferDesc.RefreshRate.Numerator = 60;
		swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
		swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		swapChainDesc.OutputWindow = windowHandle;
		swapChainDesc.Windowed = _windowConfig.windowStyle == WindowStyle::Window;
		swapChainDesc.SampleDesc.Count = 1;
		swapChainDesc.SampleDesc.Quality = 0;
		swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
		// device creation flags
		UInt32 creationFlags = 0;
#       ifdef HP_DEBUG
		creationFlags |= D3D11_CREATE_DEVICE_DEBUG;
#       endif
		HRESULT result;
		UInt8 driver = 0;
		// loop through driver types and attempt to create device
		for ( driver; driver < totalDriverTypes; ++driver )
		{
			result = D3D11CreateDeviceAndSwapChain( 0, driverTypes[driver], 0,
				creationFlags, featureLevels, totalFeatureLevels, D3D11_SDK_VERSION,
				&swapChainDesc, &_pSwapChain, &_pDevice,
				&_featureLevel, &_pDeviceContext );
			if ( SUCCEEDED( result ) )
			{
				_driverType = driverTypes[driver];
				break;
			}
		}
		if ( FAILED( result ) )
		{
			ERR( "Failed to create the Direct3D device!" );
			return false;
		}
		// back buffer texture to link render target with back buffer
		ID3D11Texture2D* backBufferTexture;
		if ( FAILED( _pSwapChain->GetBuffer( 0, _uuidof( ID3D11Texture2D ),
			(LPVOID*) &backBufferTexture ) ) )
		{
			ERR( "Failed to get the swap chain back buffer!" );
			return false;
		}
		D3D11_TEXTURE2D_DESC depthDesc;
		depthDesc.Width = _windowConfig.width;
		depthDesc.Height = _windowConfig.height;
		depthDesc.MipLevels = 1;
		depthDesc.ArraySize = 1;
		depthDesc.Format = DXGI_FORMAT_D32_FLOAT;
		depthDesc.SampleDesc.Count = 1;
		depthDesc.SampleDesc.Quality = 0;
		depthDesc.Usage = D3D11_USAGE_DEFAULT;
		depthDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
		depthDesc.CPUAccessFlags = 0;
		depthDesc.MiscFlags = 0;
		if ( FAILED( _pDevice->CreateTexture2D( &depthDesc, NULL,
			&_pDepthStencilTexture ) ) )
		{
			ERR( "Failed to create depth stencil texture!" );
			return false;
		}
		D3D11_DEPTH_STENCIL_VIEW_DESC depthViewDesc;
		depthViewDesc.Format = depthDesc.Format;
		depthViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
		depthViewDesc.Texture2D.MipSlice = 0;
		depthViewDesc.Flags = 0;
		if ( FAILED( _pDevice->CreateDepthStencilView( _pDepthStencilTexture,
			&depthViewDesc, &_pDepthStencilView ) ) )
		{
			ERR( "Failed to create depth stencil view!" );
			return false;
		}
		if ( FAILED( _pDevice->CreateRenderTargetView( backBufferTexture, NULL,
			&_pRenderTargetView ) ) )
		{
			ERR( "Failed to create render target view!" );
			HP_RELEASE( backBufferTexture );
			return false;
		}
		HP_RELEASE( backBufferTexture );
		_pDeviceContext->OMSetRenderTargets( 1, &_pRenderTargetView,
			_pDepthStencilView );
		// setup the viewport
		D3D11_VIEWPORT viewport;
		viewport.Width = static_cast<FLOAT>( _windowConfig.width );
		viewport.Height = static_cast<FLOAT>( _windowConfig.height );
		viewport.MinDepth = 0.0f;
		viewport.MaxDepth = 1.0f;
		viewport.TopLeftX = 0.f;
		viewport.TopLeftY = 0.f;
		_pDeviceContext->RSSetViewports( 1, &viewport );
		_pDeviceContext->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );
		return true;
	}
	void Renderer::preRender( )
	{
		float ClearColor[4] = { 0.0f, 0.125f, 0.3f, 1.0f };
		_pDeviceContext->ClearRenderTargetView( _pRenderTargetView,
			ClearColor );
		_pDeviceContext->ClearDepthStencilView( _pDepthStencilView,
			D3D11_CLEAR_DEPTH, 1.0f, 0 );
	}
	void Renderer::swapCameras( )
	{
		_cameraBuffer.swap( );
	}
	void Renderer::present( )
	{
		_pSwapChain->Present( 0, 0 );
	}
	bool Renderer::createVertexBuffer( ID3D11Buffer** vertexBuffer, UInt32 byteWidth,
		const Vertex* initData )
	{
		D3D11_BUFFER_DESC bd;
		bd.Usage = D3D11_USAGE_DEFAULT;
		bd.ByteWidth = byteWidth;
		bd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		bd.CPUAccessFlags = 0;
		bd.MiscFlags = 0;
		D3D11_SUBRESOURCE_DATA subresourceData;
		subresourceData.pSysMem = initData;
		subresourceData.SysMemPitch = 0;
		subresourceData.SysMemSlicePitch = 0;
		if ( SUCCEEDED( _pDevice->CreateBuffer( &bd, &subresourceData, vertexBuffer ) ) )
		{
			return true;
		}
		return false;
	}
	bool Renderer::createIndexBuffer( ID3D11Buffer** indexBuffer, UInt32 byteWidth,
		const Index* initData )
	{
		D3D11_BUFFER_DESC bd;
		bd.Usage = D3D11_USAGE_DEFAULT;
		bd.ByteWidth = byteWidth;
		bd.BindFlags = D3D11_BIND_INDEX_BUFFER;
		bd.CPUAccessFlags = 0;
		bd.MiscFlags = 0;
		D3D11_SUBRESOURCE_DATA subresourceData;
		subresourceData.pSysMem = initData;
		subresourceData.SysMemPitch = 0;
		subresourceData.SysMemSlicePitch = 0;
		if ( SUCCEEDED( _pDevice->CreateBuffer( &bd, &subresourceData, indexBuffer ) ) )
		{
			return true;
		}
		return false;
	}
	void Renderer::setVertexBuffers( ID3D11Buffer** vertexBuffer, UInt32* stride,
		UInt32* offset )
	{
		_pDeviceContext->IASetVertexBuffers( 0, 1, vertexBuffer, stride, offset );
	}
	void Renderer::setIndexBuffer( ID3D11Buffer** indexBuffer )
	{
		_pDeviceContext->IASetIndexBuffer( *indexBuffer, DXGI_FORMAT_R32_UINT, 0 );
	}
	void Renderer::setBuffers( Mesh& mesh )
	{
		UInt32 stride = sizeof( Vertex );
		UInt32 offset = 0;
		setVertexBuffers( &mesh._vertexBuffer, &stride, &offset );
		setIndexBuffer( &mesh._indexBuffer );
	}
	void Renderer::drawIndexed( UInt32 indexCount, UInt32 startIndexLocation,
		UInt32 baseVertexLocation )
	{
		_pDeviceContext->DrawIndexed( indexCount, startIndexLocation, baseVertexLocation );
	}
}

///
/// replace WinMain function with main on Windows
///
#include "pch.hpp"

#ifdef HP_PLATFORM_WIN32
extern int main( int argc, char ** argv );

int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, INT )
{
	return main( __argc, __argv );
}
#endif

#include <pch.hpp>
#include "../../include/math/frustum.hpp"
namespace hp_ip
{
	Frustum init( const float fieldOfView, const float aspectRatio, const float nearClipDist,
		const float farClipDist )
	{
		Frustum frustum;
		frustum.fieldOfView = fieldOfView;
		frustum.aspectRatio = aspectRatio;
		frustum.nearClipDist = nearClipDist;
		frustum.farClipDist = farClipDist;
		float tanHalfFov = tan( frustum.fieldOfView / 2.f );
		FVec3 nearRight = ( frustum.nearClipDist * tanHalfFov ) * frustum.aspectRatio * FVec3::right;
		FVec3 farRight = ( frustum.farClipDist * tanHalfFov ) * frustum.aspectRatio * FVec3::right;
		FVec3 nearUp = ( frustum.nearClipDist * tanHalfFov ) * frustum.aspectRatio * FVec3::up;
		FVec3 farUp = ( frustum.farClipDist * tanHalfFov ) * frustum.aspectRatio * FVec3::up;
		frustum.nearClipVerts[0] = ( frustum.nearClipDist * FVec3::forward ) - nearRight + nearUp;
		frustum.nearClipVerts[1] = ( frustum.nearClipDist * FVec3::forward ) + nearRight + nearUp;
		frustum.nearClipVerts[2] = ( frustum.nearClipDist * FVec3::forward ) + nearRight - nearUp;
		frustum.nearClipVerts[3] = ( frustum.nearClipDist * FVec3::forward ) - nearRight - nearUp;
		frustum.farClipVerts[0] = ( frustum.farClipDist * FVec3::forward ) - farRight + farUp;
		frustum.farClipVerts[1] = ( frustum.farClipDist * FVec3::forward ) + farRight + farUp;
		frustum.farClipVerts[2] = ( frustum.farClipDist * FVec3::forward ) + farRight - farUp;
		frustum.farClipVerts[3] = ( frustum.farClipDist * FVec3::forward ) - farRight - farUp;
		FVec3 origin;
		frustum.planes[static_cast<UInt8>( FrustumSides::Near )] = init( frustum.nearClipVerts[2], frustum.nearClipVerts[1], frustum.nearClipVerts[0] );
		frustum.planes[static_cast<UInt8>( FrustumSides::Far )] = init( frustum.farClipVerts[0], frustum.farClipVerts[1], frustum.farClipVerts[2] );
		frustum.planes[static_cast<UInt8>( FrustumSides::Right )] = init( frustum.farClipVerts[2], frustum.farClipVerts[1], origin );
		frustum.planes[static_cast<UInt8>( FrustumSides::Top )] = init( frustum.farClipVerts[1], frustum.farClipVerts[0], origin );
		frustum.planes[static_cast<UInt8>( FrustumSides::Left )] = init( frustum.farClipVerts[0], frustum.farClipVerts[3], origin );
		frustum.planes[static_cast<UInt8>( FrustumSides::Bottom )] = init( frustum.farClipVerts[3], frustum.farClipVerts[2], origin );
		return frustum;
	}
	bool isInside( const Frustum& frustum, const FVec3& point, const float radius )
	{
		for ( UInt8 i = 0; i < static_cast<UInt8>( FrustumSides::Count ); ++i )
		{
			if ( !isInside( frustum.planes[i], point, radius ) )
			{
				return false;
			}
		}
		return true;
	}
}

#include <pch.hpp>
#include "../../include/math/mat4x4.hpp"
namespace hp_ip
{
	const Mat4x4 Mat4x4::identity( Mat4x4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ) );
	FVec3 pos( const Mat4x4& mat )
	{
		return FVec3{ mat.m[3][0], mat.m[3][1], mat.m[3][2] };
	}
	float determinant( const Mat4x4& mat )
	{
		FVec4 v1, v2, v3;
		v1.x = mat.m[0][0];
		v1.y = mat.m[1][0];
		v1.z = mat.m[2][0];
		v1.w = mat.m[3][0];
		v2.x = mat.m[0][1];
		v2.y = mat.m[1][1];
		v2.z = mat.m[2][1];
		v2.w = mat.m[3][1];
		v3.x = mat.m[0][2];
		v3.y = mat.m[1][2];
		v3.z = mat.m[2][2];
		v3.w = mat.m[3][2];
		FVec4 x = cross( v1, v2, v3 );
		return -( mat.m[0][3] * x.x + mat.m[1][3] * x.y + mat.m[2][3] * x.z +
			mat.m[3][3] * x.w );
	}
	Mat4x4 inverse( const Mat4x4& mat )
	{
		Mat4x4 invMat;
		FVec4 vec[3];
		int i, j;
		float det = determinant( mat );
		for ( i = 0; i < 4; ++i )
		{
			for ( j = 0; j < 4; ++j )
			{
				if ( i != j )
				{
					int a = ( j <= i ) ? j : j - 1;
					vec[a].x = mat.m[j][0];
					vec[a].y = mat.m[j][1];
					vec[a].z = mat.m[j][2];
					vec[a].w = mat.m[j][3];
				}
			}
			FVec4 x = cross( vec[0], vec[1], vec[2] );
			float cofactor;
			for ( j = 0; j < 4; ++j )
			{
				switch ( j )
				{
				case 0: cofactor = x.x; break;
				case 1: cofactor = x.y; break;
				case 2: cofactor = x.z; break;
				case 3: cofactor = x.w; break;
				}
				invMat.m[j][i] = pow( -1.0f, i ) * cofactor / det;
			}
		}
		return invMat;
	}
	Mat4x4 matrixPerspectiveFovLH( const float fieldOfView, const float aspectRatio,
		const float nearClipDist, const float farClipDist )
	{
		Mat4x4 perspective;
		float tanFov = tan( fieldOfView / 2.0f );
		perspective.m[0][0] = 1.0f / ( aspectRatio * tanFov );
		perspective.m[1][1] = 1.0f / tanFov;
		perspective.m[2][2] = farClipDist / ( farClipDist - nearClipDist );
		perspective.m[2][3] = 1.0f;
		perspective.m[3][2] = ( farClipDist *  -nearClipDist ) / ( farClipDist - nearClipDist );
		perspective.m[3][3] = 0.0f;
		return perspective;
	}
	Mat4x4 rotToMat4x4( const FQuat& rot )
	{
		Mat4x4 mat;
		mat.m[0][0] = 1.0f - 2.0f * ( rot.y * rot.y + rot.z * rot.z );
		mat.m[0][1] = 2.0f * ( rot.x *rot.y + rot.z * rot.w );
		mat.m[0][2] = 2.0f * ( rot.x * rot.z - rot.y * rot.w );
		mat.m[1][0] = 2.0f * ( rot.x * rot.y - rot.z * rot.w );
		mat.m[1][1] = 1.0f - 2.0f * ( rot.x * rot.x + rot.z * rot.z );
		mat.m[1][2] = 2.0f * ( rot.y *rot.z + rot.x *rot.w );
		mat.m[2][0] = 2.0f * ( rot.x * rot.z + rot.y * rot.w );
		mat.m[2][1] = 2.0f * ( rot.y *rot.z - rot.x *rot.w );
		mat.m[2][2] = 1.0f - 2.0f * ( rot.x * rot.x + rot.y * rot.y );
		return mat;
	}
	Mat4x4 posToMat4x4( const FVec3& pos )
	{
		Mat4x4 mat;
		mat.m[3][0] = pos.x;
		mat.m[3][1] = pos.y;
		mat.m[3][2] = pos.z;
		return mat;
	}
	Mat4x4 sclToMat4x4( const FVec3& scl )
	{
		Mat4x4 mat;
		mat.m[0][0] = scl.x;
		mat.m[1][1] = scl.y;
		mat.m[2][2] = scl.z;
		return mat;
	}
	Mat4x4 rotSclPosToMat4x4( const FQuat& rot, const FVec3& scl, const FVec3& pos )
	{
		Mat4x4 mat;
		mat.m[0][0] = 1.0f - 2.0f * ( rot.y * rot.y + rot.z * rot.z );
		mat.m[0][1] = 2.0f * ( rot.x *rot.y + rot.z * rot.w );
		mat.m[0][2] = 2.0f * ( rot.x * rot.z - rot.y * rot.w );
		mat.m[1][0] = 2.0f * ( rot.x * rot.y - rot.z * rot.w );
		mat.m[1][1] = 1.0f - 2.0f * ( rot.x * rot.x + rot.z * rot.z );
		mat.m[1][2] = 2.0f * ( rot.y *rot.z + rot.x *rot.w );
		mat.m[2][0] = 2.0f * ( rot.x * rot.z + rot.y * rot.w );
		mat.m[2][1] = 2.0f * ( rot.y *rot.z - rot.x *rot.w );
		mat.m[2][2] = 1.0f - 2.0f * ( rot.x * rot.x + rot.y * rot.y );
		mat.m[3][0] = pos.x;
		mat.m[3][1] = pos.y;
		mat.m[3][2] = pos.z;
		mat.m[0][0] *= scl.x;
		mat.m[1][1] *= scl.y;
		mat.m[2][2] *= scl.z;
		return mat;

	}
}

#include <pch.hpp>
#include "../../include/math/plane.hpp"
namespace hp_ip
{
	Plane init( const FVec3& p0, const FVec3& p1, const FVec3& p2 )
	{
		FVec3 edge1, edge2, normal;
		edge1 = p1 - p0;
		edge2 = p2 - p0;
		normal = FVec3::normalize( cross( edge1, edge2 ) );
		return normalize( planeFromPointNormal( p0, normal ) );
	}
	Plane normalize( const Plane& plane )
	{
		Plane normPlane;
		float mag;
		mag = 1.0f / sqrt( plane.a * plane.a + plane.b * plane.b + plane.c * plane.c );
		normPlane.a = plane.a * mag;
		normPlane.b = plane.b * mag;
		normPlane.c = plane.c * mag;
		normPlane.d = plane.d * mag;
		return normPlane;
	}
	Plane planeFromPointNormal( const FVec3& point, const FVec3& normal )
	{
		Plane plane;
		plane.a = normal.x;
		plane.b = normal.y;
		plane.c = normal.z;
		plane.d = dot( point, normal );
		return plane;
	}
	bool isInside( const Plane& plane, const FVec3& point, const float radius )
	{
		float distance;
		distance = planeDotCoord( plane, point );
		return distance >= -radius;
	}
	float planeDotCoord( const Plane& plane, const FVec3& point )
	{
		return plane.a * point.x + plane.b * point.y + plane.c * point.z + plane.d;
	}
}

#include <pch.hpp>
#include "../../include/math/quat.hpp"
namespace hp_ip
{
	const FQuat FQuat::identity( FQuat( 0.0f, 0.0f, 0.0f, 1.0f ) );
}

#include <pch.hpp>
#include "../../include/math/vec3.hpp"
namespace hp_ip
{
	const FVec3 FVec3::zero{ 0.f, 0.f, 0.f };
	const FVec3 FVec3::right{ 1.f, 0.f, 0.f };
	const FVec3 FVec3::up{ 0.f, 1.f, 0.f };
	const FVec3 FVec3::forward{ 0.f, 0.f, 1.f };
}

#include <pch.hpp>
#include "../../include/math/vec4.hpp"
namespace hp_ip
{
	template<typename A>
	Vec4<A>::Vec4( const FVec3& vec ) : x( vec.x ), y( vec.y ), z( vec.z ), w( 1.f )
	{ }
	const FVec4 FVec4::right( 1.f, 0.f, 0.f, 0.f );
	const FVec4 FVec4::up( 0.f, 1.f, 0.f, 0.f );
	const FVec4 FVec4::forward( 0.f, 0.f, 1.f, 0.f );
}

#include <pch.hpp>
#include "../../include/utils/string.hpp"
namespace hp_ip
{
	std::wstring s2ws( const std::string& s )
	{
		int len;
		int slength = (int) s.length( ) + 1;
		len = MultiByteToWideChar( CP_ACP, 0, s.c_str( ), slength, 0, 0 );
		wchar_t* buf = new wchar_t[len];
		MultiByteToWideChar( CP_ACP, 0, s.c_str( ), slength, buf, len );
		std::wstring r( buf );
		delete[] buf;
		return r;
	}
	std::string basePath( const std::string& path )
	{
		size_t pos = path.find_last_of( "\\/" );
		return ( std::string::npos == pos ) ? "" : path.substr( 0, pos + 1 );
	}
}

#include <pch.hpp>
#include "../../include/window/window.hpp"
namespace hp_ip
{
	bool Window::open( )
	{
		if ( isOnlyInstance( ) )
		{
			// window class details
			WNDCLASSEX windowClass = { 0 };
			windowClass.cbSize = sizeof( WNDCLASSEX );
			windowClass.style = CS_VREDRAW | CS_HREDRAW;
			windowClass.lpfnWndProc = &Window::staticWindowProc;
			windowClass.cbClsExtra = 0;
			windowClass.cbWndExtra = 0;
			windowClass.hInstance = GetModuleHandle( nullptr );
			windowClass.hIcon = 0;
			windowClass.hIconSm = 0;
			windowClass.hCursor = 0;
			windowClass.hbrBackground = 0;
			windowClass.lpszMenuName = 0;
			windowClass.lpszClassName = _name.c_str( );
			// register the window
			if ( RegisterClassEx( &windowClass ) )
			{
				// find position and size
				HDC screenDC = GetDC( nullptr );
				unsigned left = ( GetDeviceCaps( screenDC, HORZRES ) - _windowConfig.width ) / 2;
				unsigned top = ( GetDeviceCaps( screenDC, VERTRES ) - _windowConfig.height ) / 2;
				unsigned width = _windowConfig.width;
				unsigned height = _windowConfig.height;
				ReleaseDC( nullptr, screenDC );
				// set the style of the window
				DWORD style = WS_VISIBLE;
				if ( _windowConfig.windowStyle == WindowStyle::Window )
				{
					style |= WS_CAPTION | WS_MINIMIZEBOX | WS_THICKFRAME | WS_MAXIMIZEBOX | WS_SYSMENU;
					// adjust the window size with the borders etc.
					RECT rectangle = { 0, 0, _windowConfig.width, _windowConfig.height };
					AdjustWindowRect( &rectangle, style, false );
					width = rectangle.right - rectangle.left;
					height = rectangle.bottom - rectangle.top;
				}
				// create the window
				_handle = CreateWindowEx( 0, _name.c_str( ), _name.c_str( ), style, left, top, width, height,
					GetDesktopWindow( ), nullptr, GetModuleHandle( nullptr ), this );
				if ( _handle == nullptr )
				{
					ERR( GetLastError( ) );
					return false;
				}
				else if ( _windowConfig.windowStyle == WindowStyle::Fullscreen )
				{
					switchToFullscreen( );
				}
				_open = true;
			}
			else
			{
				ERR( GetLastError( ) );
			}
		}
		return _open;
	}
	void Window::switchToFullscreen( )
	{
		// set display settings
		DEVMODE devMode;
		devMode.dmSize = sizeof( devMode );
		devMode.dmPelsWidth = _windowConfig.width;
		devMode.dmPelsHeight = _windowConfig.height;
		devMode.dmBitsPerPel = _windowConfig.bitsPerPx;
		devMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL;
		// change default display device settings
		if ( ChangeDisplaySettings( &devMode, CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL )
		{
			return;
		}
		// set window style
		SetWindowLong( _handle, GWL_STYLE, WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS );
		// set extended window style
		SetWindowLong( _handle, GWL_EXSTYLE, WS_EX_APPWINDOW );
		// set window size, position and z-order
		SetWindowPos( _handle, HWND_TOP, 0, 0, _windowConfig.width, _windowConfig.height,
			SWP_FRAMECHANGED );
		// show the window
		setWindowVisibility( _handle, true );
	}
	void Window::processMessages( )
	{
		MSG message;
		while ( PeekMessage( &message, _handle, 0, 0, PM_REMOVE ) )
		{
			TranslateMessage( &message );
			DispatchMessage( &message );
		}
	}
	bool Window::isOpen( )
	{
		return _open;
	}
	void Window::captureMouse( )
	{
		SetCapture( _handle );
	}
	void Window::releaseMouse( )
	{
		ReleaseCapture( );
	}
	LRESULT CALLBACK Window::windowProc( HWND handle, UINT message, WPARAM wParam,
		LPARAM lParam )
	{
		switch ( message )
		{
		case WM_CLOSE:
		{
			_open = false;
			break;
		}
		case WM_ACTIVATEAPP:
		{
			break;
		}
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
		{
			_gameInput[static_cast<Key>( wParam )] = true;
			break;
		}
		case WM_KEYUP:
		case WM_SYSKEYUP:
		{
			_gameInput[static_cast<Key>( wParam )] = false;
			break;
		}
		case WM_CHAR:
		{
			_gameInput.text = wParam;
			break;
		}
		case WM_MOUSEMOVE:
		{
			_gameInput.mouse.x = LOWORD( lParam );
			_gameInput.mouse.y = HIWORD( lParam );
			break;
		}
		case WM_LBUTTONDOWN:
		{
			captureMouse( );
			_gameInput[MouseButton::LeftButton] = true;
			break;
		}
		case WM_LBUTTONUP:
		{
			releaseMouse( );
			_gameInput[MouseButton::LeftButton] = false;
			break;
		}
		case WM_RBUTTONDOWN:
		{
			captureMouse( );
			_gameInput[MouseButton::RightButton] = true;
			break;
		}
		case WM_RBUTTONUP:
		{
			releaseMouse( );
			_gameInput[MouseButton::RightButton] = false;
			break;
		}
		case WM_MBUTTONDOWN:
		{
			captureMouse( );
			_gameInput[MouseButton::MiddleButton] = true;
			break;
		}
		case WM_MBUTTONUP:
		{
			releaseMouse( );
			_gameInput[MouseButton::MiddleButton] = false;
			break;
		}
		case WM_MOUSEWHEEL:
		{
			_gameInput.mouse.delta = HIWORD( wParam ) / 120;
			break;
		}
		case WM_XBUTTONDOWN:
		{
			captureMouse( );
			_gameInput[HIWORD( wParam ) == XBUTTON1 ? MouseButton::XButton1 : MouseButton::XButton2] = true;
			break;
		}
		case WM_XBUTTONUP:
		{
			releaseMouse( );
			_gameInput[HIWORD( wParam ) == XBUTTON1 ? MouseButton::XButton1 : MouseButton::XButton2] = false;
			break;
		}
		default:
			return DefWindowProc( handle, message, wParam, lParam );
		}
		return FALSE;
	}
	LRESULT CALLBACK Window::staticWindowProc( HWND handle, UINT message, WPARAM wParam,
		LPARAM lParam )
	{
		Window* window = reinterpret_cast<Window*>( GetWindowLongPtr( handle, GWL_USERDATA ) );
		switch ( message )
		{
		case WM_CREATE:
		{
			CREATESTRUCT *cs = reinterpret_cast<CREATESTRUCT*>( lParam );
			window = reinterpret_cast<Window*>( cs->lpCreateParams );
			SetLastError( 0 );
			if ( SetWindowLongPtr( handle, GWL_USERDATA, reinterpret_cast<LONG_PTR>( window ) )
				== 0 )
			{
				if ( GetLastError( ) != 0 )
				{
					ERR( "Unable to set window user data." );
					return FALSE;
				}
			}
			break;
		}
		default:
			return window->windowProc( handle, message, wParam, lParam );
		}
		return FALSE;
	}
	WindowConfig Window::defaultWindowConfig( )
	{
		DEVMODE mode;
		mode.dmSize = sizeof( mode );
		EnumDisplaySettings( nullptr, ENUM_CURRENT_SETTINGS, &mode );
		return WindowConfig{ mode.dmPelsWidth, mode.dmPelsHeight, WindowStyle::Default, mode.dmBitsPerPel };
	}
	void Window::setWindowVisibility( WindowHandle handle, const bool visible )
	{
		ShowWindow( handle, visible ? SW_SHOW : SW_HIDE );
		if ( visible )
		{
			SetFocus( handle );
			SetForegroundWindow( handle );
			SetActiveWindow( handle );
		}
	}
	bool Window::isOnlyInstance( )
	{
		HANDLE handle = CreateMutex( nullptr, true, _name.c_str( ) );
		if ( GetLastError( ) != ERROR_SUCCESS )
		{
			WindowHandle windowHandle = FindWindow( _name.c_str( ), nullptr );
			if ( windowHandle != nullptr )
			{
				Window::setWindowVisibility( windowHandle, true );
				return false;
			}
		}
		return true;
	}
}

